// Code generated by ChatGPT (with some bugfixes) [except solve()]

// As in Appendix B of Taubin '91

#include <Eigen/Dense>

using namespace Eigen;

namespace QuadricFitSolver {

static std::pair<MatrixXd, MatrixXd> choleskyWithFullPivoting(const MatrixXd& N) {
  // Ensure N is symmetric positive semidefinite
  if (N.rows() != N.cols()) {
    throw std::invalid_argument("Matrix N must be square.");
  }

  const int r = N.rows();

  // Perform LDLT decomposition (supports positive semidefinite matrices)
  Eigen::LDLT<MatrixXd> ldlt(N);

  if (ldlt.info() != Eigen::Success) {
    throw std::invalid_argument("LDLT decomposition failed. Ensure N is positive semidefinite.");
  }

  // Extract rank of N from the diagonal of D
  VectorXd D = ldlt.vectorD();
  const double tolerance = 1e-10;
  int rank = (D.array().abs() > tolerance).count();

  // Extract L (lower triangular part)
  MatrixXd L = ldlt.matrixL();

  // Compute L1: L scaled by sqrt(D) for positive diagonal entries, limited to rank columns
  MatrixXd L1 = L.leftCols(rank) * D.head(rank).cwiseSqrt().asDiagonal();

  // Compute L2: Orthogonal complement to L1
  MatrixXd L2 = MatrixXd::Identity(r, r).rightCols(r - rank);

  return {L1, L2};
}

// Function to extract H1, H2, H3 from the matrix H
static void extractBlocks(const MatrixXd& H, MatrixXd& H1, MatrixXd& H2, MatrixXd& H3, int h) {
  int r = H.rows();
  if (H.cols() != r) {
    throw std::invalid_argument("Matrix H must be square.");
  }
  if (h >= r || h <= 0) {
    throw std::invalid_argument("Invalid block size h.");
  }

  int r_h = r - h;

  // Extract the blocks from H
  H1 = H.bottomRightCorner(r_h, r_h);
  H2 = H.topRightCorner(h, r_h) * H1.inverse();
  H3 = H.topLeftCorner(h, h) - H2 * H1 * H2.transpose();
}

VectorXd solve(const MatrixXd &M, const MatrixXd &N, double tolerance) {
  auto [L1, L2] = choleskyWithFullPivoting(N);
  int r = 10, h = L1.cols(), k = 1;
  MatrixXd L(r, r);
  L.leftCols(h) = L1;
  L.rightCols(r - h) = L2;
  auto Linv = L.inverse();
  auto H = Linv * M * Linv.transpose();
  MatrixXd H1, H2, H3;
  extractBlocks(H, H1, H2, H3, h);
  SelfAdjointEigenSolver<Eigen::MatrixXd> solver(H3);
  if (solver.info() != Success)
    throw std::runtime_error("Reduced generalized eigenproblem failed");
  MatrixXd U1 = solver.eigenvectors().col(0).transpose();
  MatrixXd U2 = -U1 * H2;
  MatrixXd U(k, r);
  U.leftCols(h) = U1;
  U.rightCols(r - h) = U2;
  MatrixXd F = U * Linv;
  return F.row(0);
}

}
